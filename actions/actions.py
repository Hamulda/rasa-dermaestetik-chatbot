# rasa-chatbot/actions/actions.py

import json
import logging
from typing import Any, Text, Dict, List, Optional
import requests

from rasa_sdk import Action, Tracker, FormValidationAction
from rasa_sdk.executor import CollectingDispatcher
from rasa_sdk.types import DomainDict
from rasa_sdk.events import SlotSet, ActiveLoop, AllSlotsReset, ConversationPaused

# --- Profesion√°ln√≠ nastaven√≠ logov√°n√≠ ---
# Umo≈æ≈àuje detailn√≠ sledov√°n√≠ chov√°n√≠ a chyb v produkƒçn√≠m prost≈ôed√≠.
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# --- Naƒçten√≠ dat s robustn√≠m o≈°et≈ôen√≠m chyb ---
# Data se naƒçtou pouze jednou p≈ôi startu, co≈æ zaji≈°≈•uje vysok√Ω v√Ωkon.
# Pokud soubory chyb√≠ nebo jsou po≈°kozen√©, bot nespadne, ale zaloguje kritickou chybu.
try:
    with open("data/products.json", 'r', encoding='utf-8') as f:
        ALL_PRODUCTS = json.load(f)
    with open("data/knowledge_base.json", 'r', encoding='utf-8') as f:
        KNOWLEDGE_BASE = json.load(f)
except FileNotFoundError as e:
    logger.critical(f"FAT√ÅLN√ç CHYBA: Datov√Ω soubor nebyl nalezen. Chatbot nem≈Ø≈æe doporuƒçovat produkty. Chyba: {e}")
    ALL_PRODUCTS, KNOWLEDGE_BASE = [], {}
except json.JSONDecodeError as e:
    logger.critical(f"FAT√ÅLN√ç CHYBA: Chyba v JSON form√°tu datov√©ho souboru. Chatbot nem≈Ø≈æe doporuƒçovat produkty. Chyba: {e}")
    ALL_PRODUCTS, KNOWLEDGE_BASE = [], {}

# --- Glob√°ln√≠ konstanty ---
PRODUCTS_PER_PAGE = 3
BASE_ESHOP_URL = "https://eshop.dermaestetik.cz/"

# --- Pomocn√° funkce pro zobrazen√≠ produkt≈Ø ---
def display_products(dispatcher: CollectingDispatcher, products: List[Dict[Text, Any]], title: Optional[Text] = None):
    """
    Inteligentnƒõ form√°tuje a odes√≠l√° u≈æivateli seznam produkt≈Ø.
    P≈ôid√°v√° prodejn√≠ prvky jako "Bestseller" pro zv√Ω≈°en√≠ konverze.
    """
    if not products:
        dispatcher.utter_message(response="utter_no_products_found")
        return

    if title:
        dispatcher.utter_message(text=title)

    elements = []
    for product in products:
        payload = f'/get_product_details{{"product_name": "{product["name"]}"}}'
        buttons = [
            {"title": "V√≠ce informac√≠", "payload": payload, "type": "postback"},
            {"title": "Koupit na e-shopu", "url": product.get('link', BASE_ESHOP_URL), "type": "web_url"}
        ]
        
        # P≈ôid√°n√≠ prodejn√≠ch "badges" pro vytvo≈ôen√≠ urgence a soci√°ln√≠ho d≈Økazu
        subtitle = f"Cena: {product.get('price', 'N/A')} Kƒç"
        if product.get('bestseller'):
            subtitle = f"üî• BESTSELLER | {subtitle}"
        if product.get('stock_level') == 'low':
            subtitle = f"‚ö†Ô∏è POSLEDN√ç KUSY | {subtitle}"

        elements.append({
            "title": f"{product.get('brand', 'N/A')} - {product.get('name', 'Produkt')}",
            "subtitle": subtitle,
            "image_url": product.get('image_url', f'https://placehold.co/600x400/E8E8E8/444444?text={product.get("name")}'),
            "buttons": buttons
        })
    
    dispatcher.utter_message(attachment={"type": "template", "payload": {"template_type": "generic", "elements": elements}})

# ==============================================================================
# KL√çƒåOV√â AKCE CHATBOTA
# ==============================================================================

class ActionRecommendProduct(Action):
    """Hlavn√≠ akce pro doporuƒçen√≠ produkt≈Ø s implementovanou cross-sell logikou."""
    def name(self) -> Text: return "action_recommend_product"

    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict) -> List[Dict]:
        if not ALL_PRODUCTS:
            dispatcher.utter_message(text="Omlouv√°m se, datab√°ze produkt≈Ø nen√≠ moment√°lnƒõ dostupn√°.")
            return []

        skin_type = tracker.get_slot('skin_type') or []
        skin_concern = tracker.get_slot('skin_concern') or []
        logger.info(f"Filtruji produkty s krit√©rii: Ple≈•={skin_type}, Probl√©m={skin_concern}")

        filtered_products = [p for p in ALL_PRODUCTS if (not skin_type or any(st.lower() in [s.lower() for s in p.get('skin_types', [])] for st in skin_type)) and (not skin_concern or any(sc.lower() in [s.lower() for s in p.get('skin_concerns', [])] for sc in skin_concern))]

        if not filtered_products:
            dispatcher.utter_message(response="utter_no_products_found")
            return []

        display_products(dispatcher, filtered_products[:PRODUCTS_PER_PAGE], title=f"Na≈°la jsem {len(filtered_products)} skvƒõl√Ωch produkt≈Ø. Zde jsou ty nejlep≈°√≠:")
        
        # --- PRODEJN√ç STRATEGIE: CROSS-SELL ---
        if len(filtered_products) > 0:
            first_product = filtered_products[0]
            complementary_ids = first_product.get('complementary_products', [])
            if complementary_ids:
                complementary_product = next((p for p in ALL_PRODUCTS if p.get('id') in complementary_ids), None)
                if complementary_product:
                    payload = f'/get_product_details{{"product_name": "{complementary_product["name"]}"}}'
                    dispatcher.utter_message(
                        text=f"üí° **PRO TIP:** Pro maxim√°ln√≠ √∫ƒçinek doporuƒçuji k produktu **{first_product['name']}** p≈ôidat i **{complementary_product['name']}**. Pos√≠l√≠ jeho efekt a dod√° pleti komplexn√≠ p√©ƒçi.",
                        buttons=[{"title": f"Zjistit v√≠c o {complementary_product['name']}", "payload": payload, "type": "postback"}]
                    )

        return [SlotSet("last_recommended_ids", [p['id'] for p in filtered_products]), SlotSet("recommendation_page", 1.0)]

class ActionRecommendRoutine(Action):
    """Sestav√≠ a doporuƒç√≠ kompletn√≠ peƒçuj√≠c√≠ rutinu, ƒç√≠m≈æ zvy≈°uje hodnotu objedn√°vky."""
    def name(self) -> Text: return "action_recommend_routine"
    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict) -> List[Dict]:
        routine_type = next(tracker.get_latest_entity_values("routine_type"), "kompletn√≠")
        skin_concern = tracker.get_slot("skin_concern") or []

        if not skin_concern:
            dispatcher.utter_message(text="Abych v√°m mohla sestavit rutinu, pot≈ôebuji vƒõdƒõt, jak√Ω hlavn√≠ probl√©m ≈ôe≈°√≠te (nap≈ô. akn√©, vr√°sky).")
            return [SlotSet("skin_concern", None)]
        
        logger.info(f"Sestavuji '{routine_type}' rutinu pro probl√©m: {skin_concern}")
        
        # Zde by byla komplexn√≠ logika. Pro uk√°zku vyb√≠r√°me kl√≠ƒçov√© kategorie.
        # V re√°ln√©m svƒõtƒõ by tato logika mohla b√Ωt mnohem sofistikovanƒõj≈°√≠.
        routine_map = {
            "cleanser": next((p for p in ALL_PRODUCTS if "ƒçistic√≠" in p.get('category','').lower() and any(sc.lower() in p.get('skin_concerns', []) for sc in skin_concern)), None),
            "serum": next((p for p in ALL_PRODUCTS if "s√©rum" in p.get('category','').lower() and any(sc.lower() in p.get('skin_concerns', []) for sc in skin_concern)), None),
            "cream": next((p for p in ALL_PRODUCTS if "kr√©m" in p.get('category','').lower() and any(sc.lower() in p.get('skin_concerns', []) for sc in skin_concern)), None),
            "spf": next((p for p in ALL_PRODUCTS if "spf" in p.get('category','').lower()), None) if routine_type == "rann√≠" else None
        }
        routine_products = [p for p in routine_map.values() if p]

        if len(routine_products) < 2: # Rutina ned√°v√° smysl, pokud nem√° aspo≈à 2 produkty
            dispatcher.utter_message(response="utter_suggest_consultation")
            return []
            
        total_price = sum(p.get('price', 0) for p in routine_products)
        display_products(dispatcher, routine_products, title=f"Sestavila jsem pro v√°s ide√°ln√≠ **{routine_type} rutinu** pro ≈ôe≈°en√≠ probl√©mu **{skin_concern[0]}**. Celkov√° cena: {total_price} Kƒç.")
        return []

class ActionGetProductDetails(Action):
    """Z√≠sk√° a zobraz√≠ detailn√≠ informace o konkr√©tn√≠m produktu."""
    def name(self) -> Text: return "action_get_product_details"

    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict) -> List[Dict]:
        product_name = next(tracker.get_latest_entity_values("product_name"), None)
        if not product_name:
            dispatcher.utter_message(text="Omlouv√°m se, nerozpoznala jsem, na kter√Ω produkt se pt√°te.")
            return []

        product = next((p for p in ALL_PRODUCTS if p['name'].lower() == product_name.lower()), None)
        if not product:
            dispatcher.utter_message(text=f"Produkt '{product_name}' se mi nepoda≈ôilo naj√≠t v datab√°zi.")
            return []
        
        description = product.get("description", "Popis nen√≠ k dispozici.")
        message = f"**{product.get('brand')} - {product.get('name')}**\n\n{description}"
        dispatcher.utter_message(text=message)
        dispatcher.utter_message(response="utter_anything_else")
        return []


class ActionShowNextProducts(Action):
    """Zobraz√≠ dal≈°√≠ str√°nku produkt≈Ø z p≈ôedchoz√≠ho vyhled√°v√°n√≠."""
    def name(self) -> Text: return "action_show_next_products"
    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict) -> List[Dict]:
        last_recommended_ids = tracker.get_slot("last_recommended_ids") or []
        page = tracker.get_slot("recommendation_page") or 1.0

        if not last_recommended_ids:
            dispatcher.utter_message(text="Nejprve mus√≠me naj√≠t nƒõjak√© produkty. Zkuste nov√© vyhled√°v√°n√≠.")
            return []

        start_index = int(page * PRODUCTS_PER_PAGE)
        if start_index >= len(last_recommended_ids):
            dispatcher.utter_message(text="U≈æ jsem v√°m uk√°zala v≈°echny nalezen√© produkty.")
            return []

        end_index = start_index + PRODUCTS_PER_PAGE
        next_product_ids = last_recommended_ids[start_index:end_index]
        products_to_show = [p for p in ALL_PRODUCTS if p['id'] in next_product_ids]

        display_products(dispatcher, products_to_show)
        return [SlotSet("recommendation_page", page + 1.0)]


# ==============================================================================
# FORMA A VALIDACE
# ==============================================================================

class ValidateProductRecommendationForm(FormValidationAction):
    """Validuje vstupy pro formul√°≈ô a zaji≈°≈•uje, ≈æe jsou smyslupln√©."""
    def name(self) -> Text: return "validate_product_recommendation_form"

    def _validate_input(self, value: Any, known_values_key: str) -> Optional[List[Text]]:
        if not isinstance(value, list): value = [value]
        known_values = [v.lower() for v in KNOWLEDGE_BASE.get(known_values_key, [])]
        validated = [item for item in value if item.lower() in known_values]
        return validated or None

    async def validate_skin_type(self, value: Any, dispatcher: CollectingDispatcher, **kwargs) -> Dict[Text, Any]:
        validated = self._validate_input(value, "KNOWN_SKIN_TYPES")
        if not validated:
            dispatcher.utter_message(text=f"Typ pleti '{value}' nezn√°m. Zkuste pros√≠m jednu z mo≈ænost√≠: such√°, mastn√°, sm√≠≈°en√°, citliv√°.")
            return {"skin_type": None}
        return {"skin_type": validated}

    async def validate_skin_concern(self, value: Any, dispatcher: CollectingDispatcher, **kwargs) -> Dict[Text, Any]:
        validated = self._validate_input(value, "KNOWN_SKIN_CONCERNS")
        if not validated:
            dispatcher.utter_message(text=f"Probl√©m '{value}' nezn√°m. Zkuste pros√≠m: akn√©, vr√°sky, p√≥ry, pigmentace.")
            return {"skin_concern": None}
        return {"skin_concern": validated}

# ==============================================================================
# GDPR A UTILITN√ç AKCE
# ==============================================================================

class ActionSetGdprConsent(Action):
    """Nastav√≠ souhlas s GDPR."""
    def name(self) -> Text: return "action_set_gdpr_consent"
    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict) -> List[Dict]:
        return [SlotSet("gdpr_consent", True)]

class ActionManageGdpr(Action):
    """Zpracov√°v√° export a maz√°n√≠ u≈æivatelsk√Ωch dat."""
    def name(self) -> Text: return "action_manage_gdpr"
    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict) -> List[Dict]:
        intent_name = tracker.latest_message['intent'].get('name')
        
        if intent_name == "gdpr_export":
            dispatcher.utter_message(response="utter_gdpr_export_info")
            events = json.dumps(tracker.events, indent=2)
            dispatcher.utter_message(text=f"```json\n{events}\n```")
            logger.info(f"Export dat pro u≈æivatele {tracker.sender_id}")
        elif intent_name == "gdpr_delete" or (tracker.latest_action_name == "utter_gdpr_delete_confirm" and intent_name == "affirm"):
            logger.info(f"Po≈æadavek na smaz√°n√≠ dat pro u≈æivatele {tracker.sender_id}.")
            dispatcher.utter_message(response="utter_gdpr_deleted")
            # V re√°ln√©m nasazen√≠ by zde bylo vol√°n√≠ API pro smaz√°n√≠ dat
            # Pro simulaci ukonƒç√≠me konverzaci a po dal≈°√≠m startu bude pr√°zdn√°.
            return [ConversationPaused(), AllSlotsReset()]
        return []

class ActionResetSlots(Action):
    """Akce pro resetov√°n√≠ v≈°ech slot≈Ø a restart konverzace."""
    def name(self) -> Text: return "action_reset_slots"
    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict) -> List[Dict]:
        return [AllSlotsReset()]
        
class ActionDefaultFallback(Action):
    """
    Inteligentn√≠ fallback. Pokud si bot nen√≠ jist√Ω, nab√≠dne nejƒçastƒõj≈°√≠ akce
    nebo konzultaci.
    """
    def name(self) -> Text:
        return "action_default_fallback"

    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict) -> List[Dict[Text, Any]]:
        dispatcher.utter_message(
            text="Omlouv√°m se, teƒè jsem v√°m √∫plnƒõ nerozumƒõla. Mohu pro v√°s zkusit:",
            buttons=[
                {"title": "Doporuƒçit produkt", "payload": "/ask_product_recommendation"},
                {"title": "Sestavit rutinu", "payload": "/ask_for_routine"},
                {"title": "Objednat konzultaci", "payload": "/book_consultation"},
            ]
        )
        return []

